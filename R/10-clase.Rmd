---
title: "Regresión logística"
linktitle: "10: Regresión logística"
date: "2021-08-24"
menu:
  example:
    parent: Ejemplos
    weight: 10
type: docs
toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 0. Objetivos del práctico

Este práctico tiene por objetivo presentar cómo crear modelos de regresión logística en R, con predictores categóricos y cuantitativos; cómo exponenciar los coeficientes para facilitar su interpretación; y, por último, herramientas de visualización de los modelos generados. 

## 1. Recursos del práctico

Este práctico fue elaborado con datos de la [**Encuesta Suplementaria de Ingresos (ESI)**](https://www.ine.cl/estadisticas/sociales/ingresos-y-gastos/encuesta-suplementaria-de-ingresos) en su versión 2020. Cuando trabajen con algún set de datos, nunca olviden revisar la documentación metodológica anexa, así como el [libro de códigos](https://www.ine.cl/docs/default-source/encuesta-suplementaria-de-ingresos/bbdd/manual-y-guía-de-variables/2020/personas-esi-2020.pdf?sfvrsn=f196cb4e_4) correspondiente. 

## 2. Librerías a utilizar

En este práctico utilizaremos cuatro paquetes

1. `pacman`: este facilita y agiliza la lectura de los paquetes a utilizar en R

2. `sjmisc`: explorar datos

3. `tidyverse`: colección de paquetes, del cuál utilizaremos `dplyr` y `haven`

4. `haven`: para transformar variables

5. `dplyr`: nos permite seleccionar variables de un set de datos

6. `texreg`: nos permite construir tablas de regresión en RMarkdown

7. `summarytools`: para hacer tablas descriptivas

8. `sjPlot`: para construir tablas y gráficos

# Pasos del procesamiento

## 1. Cargar librerías

Como en las prácticas anteriores, empleamos la función `p_load` de la librería `pacman` 

```{r packages, include=TRUE}
pacman::p_load(sjmisc,
               tidyverse,
               haven,
               dplyr,
               summarytools)
```

La librería `texreg`, si bien está disponible en CRAN (de donde se descargan e instalan los paquetes por defecto), tal versión no nos permite usar el argumento `custom.gof.rows`, que nos permite incorporar estadísticos de ajuste adicionales. Por ello, la instalaremos directamente desde _GitHub_

```{r texreg, message=FALSE, include=TRUE}
remotes::install_github("leifeld/texreg")
library(texreg)
```

## 2. Cargar datos

Como se señaló anteriormente, en este práctico se trabajará con los datos de la **Encuesta Suplementaria de Ingresos (ESI)** en su versión 2020. Esta se encuentra en la carpeta "input/data", en formato .rds, habiendo sido procesada anteriormente. Por ello, empleamos la función `readRDS()` de la librería `base` de R.

```{r read_dta, echo=TRUE}
datos <- readRDS("../input/data/datos_proc.rds")
```

Podemos darnos cuenta de que el set de datos presenta 71.935 observaciones (o filas), y 4 variables (o columnas), que incluyen a las variables `ingresos`, `educacion`, `sexo` y `edad`.

## 3. Explorar datos

A continuación, usaremos la función `view_df()` del paquete `sjPlot`, que presenta un resumen de las variables contenidas en el set de datos, que nos permitirá identificar la _etiqueta_ de cada variable y de cada una de sus alternativas de respuesta. 

```{r view-df, echo=TRUE, message=FALSE}
sjPlot::view_df(datos)
```

Podemos ver que tenemos dos variables cuantitativas (`ingresos` y `edad`), y dos variables categóricas (`sexo` y `educacion`). Estas últimas tienen 2 y 10 categorías, respectivamente. Sin embargo, en el caso de educacion, el valor `999` indica _Nivel ignorado_, es decir, valores nulos. En consideración de ello, ahora toca recodificar las variables y establecer los datatypes adecuados para poder generar el modelo de forma correcta. 

## 4. Transformación de variables

Primero, debemos cerciorarnos de que el nivel de medición corresponda con el datatype de cada columna. Para ello, emplearemos el comando `class()` del paquete `base` de R.

```{r class, echo=T, include=F}
class(datos$ingresos)
class(datos$educacion)
class(datos$sexo)
class(datos$edad)
```

Las variables `ingresos` y `edad` presentan un `class()` de tipo `numeric`, por lo cual no es necesario realizar modificaciones. Sin embargo, las variables `educacion` y `sexo` deben ser transformadas en `factor` para trabajar con ellas de manera adecuada. Para ello, empleamos la función `as_factor()` del paquete `haven`. Una de las ventajas de esta función es que nos permite **mantener las etiquetas** de nuestras variables.

```{r factor, echo=T, include=F}
datos$educacion <- as_factor(datos$educacion)
class(datos$educacion)
datos$sexo <- as_factor(datos$sexo)
class(datos$sexo)
```

## 5. Recodificaciones

La variable `educacion` presenta la categoría de respuesta `Nivel ignorado`, que realmente presenta casos perdidos. Para ello, usaremos la función `recode()` de la librería `car`, para transformar tales valores en `NA`. Asimismo, se unificarán las categorías `Educación primaria (nivel 1)` y `Educación primaria (nivel 2)`; y renombraremos `Educación técnica (Educación superior no universitaria)` como `Educación técnica` para facilitar el análisis. También nos damos cuenta de que las niveles (`levels`) de la variable no están ordenados de menor a mayor nivel educacional, por lo cual utilizaremos el argumento `levels` de la función `as.factor` del paquete `base` de R, para ordenarlos de forma adecuada. 

```{r recode, echo=T}
datos$educacion <- car::recode(datos$educacion, recodes = c("'Nivel ignorado' = NA; 
                                                  c('Educación primaria (nivel 1)', 'Educación primaria (nivel 2)') = 'Educación primaria'; 
                                                  'Educación técnica (Educación superior no universitaria)' = 'Educación técnica'")) 
                     
datos$educacion <- factor(datos$educacion, levels = c('Nunca estudió', 
                                     'Educación preescolar', 
                                     'Educación primaria', 
                                     'Educación secundaria', 
                                     'Educación técnica', 
                                     'Educación universitaria', 
                                     'Postitulos y maestría', 
                                     'Doctorado'))
```

## 5.1. Creación de variable dependiente dicotómica

Como señalamos al inicio del práctico, la **variable dependiente** de este modelo de regresión logística será una dicotomización de la variable ingresos. Esta se construirá codificando como `1` a todas aquellas personas cuyos ingresos sean mayores a la media de ingresos, y como `0` a todas las otras personas. Para ello, emplearemos la función `ifelse()` del paquete `base` de R, a modo de generar una variable condicional a partir de lo anteriormente. 

```{r crear-dependiente, echo=T}
datos$ingresos_d <- ifelse(datos$ingresos>mean(datos$ingresos), 1, 0)
```


## 6. Análisis descriptivos

Una vez que tengamos recodificadas las variables, debemos proceder con un análisis descriptivo de los datos. Para ello, emplaremos la función `dfSummary()` de la librería `summarytools`, que nos permite crear una tabla descriptiva para todas las variables de nuestro set de datos.

```{r descriptivo, echo=T, message=F}
view(dfSummary(datos, headings = FALSE, method = "render"))
```

Podemos ver que la media de la variable `ingresos` es 162.615.6. Asimismo, las categorías con mayor frecuencia en `educacion` son Educación primaria (30.4%) y Educación secundaria (36.2%). En la muestra, por otra parte, hay más mujeres (53%) que hombres (47%). Por su parte, la media de `edad` son 39.3 años. Por último, el 75.9% de las personas tiene ingresos menores o iguales al ingreso medio, mientras que un 24.1% percibe ingresos superiores al ingreso medio. 

## 7. Creación del modelo

Una vez realizado lo anterior, es momento de generar nuestro modelo de regresión logística. Emplearemos la función `glm()` del paquete base de `R`, especificando el argumento `family` como `"binomial"`. Lo primero es especificar las variables con las cuales construiremos el modelo: antes de la virgulilla (~) escribiremos nuestra variable dependiente (en este caso, `ingresos_d`), y luego, las variables independientes (aquí, `educacion`, `sexo` y `edad`), separadas con un signo más (+).


```{r modelo-log, echo=T, message=F}
modelo <- glm(ingresos_d~educacion+sexo+edad, data = datos, family = "binomial")
```

Como podemos ver, se ha creado en nuestro entorno (Environment) un objeto llamado `modelo`. Sin embargo, así como está el objeto no nos provee de información útil, por lo que emplearemos el paquete `texreg` para visualizarlo.

## 8. Visualización del modelo

A continuación, visualizaremos el modelo con el comando `tab_model()` de la librería `sjPlot`. Por defecto, para las medidas de ajuste, se emplea el R^^2 de Tjur (Pseudo-R^^2)

```{r tabla, results= 'asis', echo=T, message=F}
sjPlot::tab_model(modelo, 
                  show.ci=FALSE, 
                  p.style = "stars", 
                  dv.labels = "Modelo",
                  string.pred = "Predictores", 
                  string.est = "β")
```

También es posible visualizar los modelos con el comando `htmlreg()` del paquete `texreg`, que genera una tabla en formato HTML.

```{r tabla-html, results= 'asis', echo=T, message=F}
htmlreg(modelo)
```

Para el caso de las variables categóricas (que han sido transformadas a tipo `factor`), R toma como categoría de referencia al primer nivel (`level`) de la variable. En el caso de de `educacion`, por ejemplo, la categoría de referencia es _Nunca estudió_; y para `sexo`, la categoría de referencia es _Hombre_. Sin embargo, podemos emplear la función `relevel` para establecer una nueva categoría de referencia para una variable en particular. Probemos estableciendo la categoría _Mujer_ como la referencia para la variable `sexo`:

```{r relevel, echo=TRUE}
datos$sexo <- relevel(datos$sexo, ref = 'Mujer')
```

Volvemos a generar y visualizar el modelo, creando un nuevo objeto llamado `modelo_r`, y visualizando ambos con `htmlreg()`

```{r modelo-relevel, results= 'asis', echo=T, message=F}
modelo_r <- glm(ingresos_d~educacion+sexo+edad, data = datos, family = "binomial")
htmlreg(list(modelo, modelo_r))
```

Podemos darnos cuenta de que el _output_ de este código incluye a ambos modelos, uno junto a otro. Las tablas generadas con `htmlreg()` incluyen cada uno de los coeficientes y sus niveles de significancia estadística (señalados con asteriscos *), así como distintas medidas de ajuste como _AIC_ o _Log Likelihood_. 

### Control estadístico

En general, nuestra interpretación la elaboraremos centrándonos en la **significancia estadística** de nuestros coeficientes. Para ello, podemos graficar la significancia estadística con la función `plot_model()` del paquete `sjPlot`

```{r sig-est, echo=T}
plot_model(modelo, show.values = TRUE)+ theme_sjplot()
```

## 11. Exponenciación de los coeficientes

No obstante, por defecto el comando `glm()` arroja los coeficientes como **logaritmos de las chanches** (Log-odds). Así, extraemos las log-odds de nuestro modelo, y luego las exponenciamos con la función `exp()` para transformarlas en odds-ratio:

```{r log-odds, echo=T}
or <- texreg::extract(modelo)
or@coef <- exp(or@coef)
```

```{r tabla, results= 'asis', echo=T, message=F}
# sjPlot::tab_model(list(modelo, or), 
#                   show.ci=FALSE, 
#                   p.style = "stars", 
#                   dv.labels = c("Modelo"," Modelo (OR)"),
#                   string.pred = "Predictores", 
#                   string.est = "β")
```

Y, por último, visualizamos la tabla con nuestro modelo en log-odds y odds ratio (chances)en formado html con la función `htmlreg()` de la librería `texreg`

``` {r modelo-or, results= 'asis', echo=T}
htmlreg(l = list(modelo, or), doctype = F, 
        caption = "", caption.above = T, 
        custom.model.names = c("Modelo", "Modelo (OR)"), 
        ci.force = c(TRUE, TRUE), override.coef = list(coef(modelo), or@coef), 
        custom.note = "$^{***}$ p < 0.001; $^{**}$ p < 0.01; $^{*}$ p < 0.05 <br> Errores estándar entre paréntesis. <br> **Nota**: La significancia estadística de los coeficientes en unidades de Odds ratio está calculada en base a los valores $t$, <br> los cuales a su vez se calculan en base a $log(Odds)/SE$")

```

También podemos graficar la significancia estadística de nuestros coeficientes, con `plot_model()` de `sjPlot`

```{r plot-sig, echo=T}
#plot_model(list(modelo, or), show.values = TRUE)+ theme_sjplot()
```


## 10. Medidas de ajuste

## 11. Resumen